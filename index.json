[{"categories":["coding","programming"],"content":"Imagine you are writing a very convoluted program with all sorts of threading magic. You want to continuously test various sections of your program before moving on with the next task. Would you rather write all the functions in the file at the same time and start debugging the code for errors, or would you rather fire up an ipython shell with your program loaded up and available to you? ","date":"2021-06-03","objectID":"/running-ipython-inside-a-python-script/:0:0","tags":["python","hacking"],"title":"Running ipython inside a python script","uri":"/running-ipython-inside-a-python-script/"},{"categories":["coding","programming"],"content":"An interactive shell within your script I would rather do the later. IPython makes it incredibly simple to test your code from time to time. This is a fairly basic thing to do but i find it incredibly useful. In my case, i like having a shell which i can interact, if for example i am algotrading. A simple pause function can be triggered within ipython, and manual trading can be done before switching back to algotrading. # Some Threaded Code running in the background import IPython IPython.embed() And you have an ipython shell running. Alternatively you can make use of an eval statement # Put this at the top of your program import readline def interactive_eval(): while True: eval(input()) i_eval = threading.Thread(target=interactive_eval) i_eval.start() # Follow up with rest of your program Note: Make sure you end with os.system('stty sane'). ","date":"2021-06-03","objectID":"/running-ipython-inside-a-python-script/:1:0","tags":["python","hacking"],"title":"Running ipython inside a python script","uri":"/running-ipython-inside-a-python-script/"},{"categories":["coding","programming"],"content":"References IPython — IPython 7.24.1 documentation ","date":"2021-06-03","objectID":"/running-ipython-inside-a-python-script/:2:0","tags":["python","hacking"],"title":"Running ipython inside a python script","uri":"/running-ipython-inside-a-python-script/"},{"categories":["coding","programming"],"content":"Qutebrowser Qutebrowser is the best web browser for developers, hands down. Nothing can compare to the flexibility it offers. Now, ofcourse other web browser must have ways of enabling and disabling various fancy features, but it’s much harder to achieve. I have a number of scripts that i use on a daily basis in qutebrowser which i maintain here (dotfiles/Browser/Qutebrowser/userscripts at master · SidharthArya/dotfiles ) on a daily basis. ","date":"2021-06-04","objectID":"/a-quicker-way-to-reach-localhost-with-qutebrowser/:1:0","tags":["browser","qutebrowser","dev","hacking"],"title":"A quicker way to reach localhost with qutebrowser","uri":"/a-quicker-way-to-reach-localhost-with-qutebrowser/"},{"categories":["coding","programming"],"content":"The Problem One of the issues i have sometimes is to reach localhost on various ports quickly. For example, i may have a hugo server running on port 1313 accessed as https://localhost:1313 and i may have an org-roam-server running on port 8080 accessed as https://localhost:8080. Using the regular history matching of a web browser may work, nonetheless, some developing environments have dynamic allocation of ports. So it may associate a port number at random with its services. In this specific case history matching does not work for me. Also history matching feels a lot slower in every browser compared to what we can do in qutebrowser. So, what i do is i write a simple qutebrowser userscript as follows: ","date":"2021-06-04","objectID":"/a-quicker-way-to-reach-localhost-with-qutebrowser/:2:0","tags":["browser","qutebrowser","dev","hacking"],"title":"A quicker way to reach localhost with qutebrowser","uri":"/a-quicker-way-to-reach-localhost-with-qutebrowser/"},{"categories":["coding","programming"],"content":"Solution Create a file called localhost at ~/.local/share/qutebrowser/userscripts or ~/.config/qutebrowser/userscripts. Write the code below in that file: #!/bin/bash if [ -z $QUTE_COUNT ]; then QUTE_COUNT=8080 fi echo open localhost:$QUTE_COUNT \u003e $QUTE_FIFO Save the file and add a key combination for the script in your config.py usually placed at ~/.config/qutebrowser/config.py. config.bind('zl', 'spawn --userscript localhost') ","date":"2021-06-04","objectID":"/a-quicker-way-to-reach-localhost-with-qutebrowser/:3:0","tags":["browser","qutebrowser","dev","hacking"],"title":"A quicker way to reach localhost with qutebrowser","uri":"/a-quicker-way-to-reach-localhost-with-qutebrowser/"},{"categories":["coding","programming"],"content":"Usage If you need to go to https://localhost:8080. Type 8080zl in normal mode in qutebrowser. 8000 is the default port and so just typing zl would take you to https://localhost:8000. ","date":"2021-06-04","objectID":"/a-quicker-way-to-reach-localhost-with-qutebrowser/:4:0","tags":["browser","qutebrowser","dev","hacking"],"title":"A quicker way to reach localhost with qutebrowser","uri":"/a-quicker-way-to-reach-localhost-with-qutebrowser/"},{"categories":["coding","programming"],"content":"References qutebrowser | qutebrowser Writing qutebrowser userscripts | qutebrowser ","date":"2021-06-04","objectID":"/a-quicker-way-to-reach-localhost-with-qutebrowser/:5:0","tags":["browser","qutebrowser","dev","hacking"],"title":"A quicker way to reach localhost with qutebrowser","uri":"/a-quicker-way-to-reach-localhost-with-qutebrowser/"}]